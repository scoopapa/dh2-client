{
  "version": 3,
  "sources": ["../../../../data/mods/gen1jpn/moves.ts"],
  "sourcesContent": ["/**\n * The japanese version of Blizzard in Gen 1 had a 30% chance to freeze\n */\n\nexport const Moves: import('../../../sim/dex-moves').ModdedMoveDataTable = {\n\tblizzard: {\n\t\tinherit: true,\n\t\tsecondary: {\n\t\t\tchance: 30,\n\t\t\tstatus: 'frz',\n\t\t},\n\t},\n\tsubstitute: {\n\t\tinherit: true,\n\t\tcondition: {\n\t\t\tonStart(target) {\n\t\t\t\tthis.add('-start', target, 'Substitute');\n\t\t\t\tthis.effectState.hp = Math.floor(target.maxhp / 4) + 1;\n\t\t\t\tdelete target.volatiles['partiallytrapped'];\n\t\t\t},\n\t\t\tonTryHitPriority: -1,\n\t\t\tonTryHit(target, source, move) {\n\t\t\t\tif (move.drain) {\n\t\t\t\t\tthis.add('-miss', source);\n\t\t\t\t\tthis.hint(\"In the Japanese versions of Gen 1, draining moves always miss against substitutes.\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (move.category === 'Status') {\n\t\t\t\t\t// In gen 1 it only blocks:\n\t\t\t\t\t// poison, confusion, secondary effect confusion, stat reducing moves and Leech Seed.\n\t\t\t\t\tconst subBlocked = ['lockon', 'meanlook', 'mindreader', 'nightmare'];\n\t\t\t\t\tif ((move.status && ['psn', 'tox'].includes(move.status)) || (move.boosts && target !== source) ||\n\t\t\t\t\t\tmove.volatileStatus === 'confusion' || subBlocked.includes(move.id)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (move.volatileStatus && target === source) return;\n\t\t\t\t// NOTE: In future generations the damage is capped to the remaining HP of the\n\t\t\t\t// Substitute, here we deliberately use the uncapped damage when tracking lastDamage etc.\n\t\t\t\t// Also, multi-hit moves must always deal the same damage as the first hit for any subsequent hits\n\t\t\t\tlet uncappedDamage = move.hit > 1 ? this.lastDamage : this.actions.getDamage(source, target, move);\n\t\t\t\tif (!uncappedDamage && uncappedDamage !== 0) return null;\n\t\t\t\tuncappedDamage = this.runEvent('SubDamage', target, source, move, uncappedDamage);\n\t\t\t\tif (!uncappedDamage && uncappedDamage !== 0) return uncappedDamage;\n\t\t\t\tthis.lastDamage = uncappedDamage;\n\t\t\t\ttarget.volatiles['substitute'].hp -= uncappedDamage > target.volatiles['substitute'].hp ?\n\t\t\t\t\ttarget.volatiles['substitute'].hp : uncappedDamage;\n\t\t\t\tif (target.volatiles['substitute'].hp <= 0) {\n\t\t\t\t\ttarget.removeVolatile('substitute');\n\t\t\t\t\ttarget.subFainted = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis.add('-activate', target, 'Substitute', '[damage]');\n\t\t\t\t}\n\t\t\t\t// Drain/recoil does not happen if the substitute breaks\n\t\t\t\tif (target.volatiles['substitute']) {\n\t\t\t\t\tif (move.recoil) {\n\t\t\t\t\t\tthis.damage(Math.round(uncappedDamage * move.recoil[0] / move.recoil[1]), source, target, 'recoil');\n\t\t\t\t\t}\n\t\t\t\t\tif (move.drain) {\n\t\t\t\t\t\tthis.heal(Math.ceil(uncappedDamage * move.drain[0] / move.drain[1]), source, target, 'drain');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.runEvent('AfterSubDamage', target, source, move, uncappedDamage);\n\t\t\t\t// Add here counter damage\n\t\t\t\tconst lastAttackedBy = target.getLastAttackedBy();\n\t\t\t\tif (!lastAttackedBy) {\n\t\t\t\t\ttarget.attackedBy.push({source: source, move: move.id, damage: uncappedDamage, thisTurn: true, slot: source.getSlot()});\n\t\t\t\t} else {\n\t\t\t\t\tlastAttackedBy.move = move.id;\n\t\t\t\t\tlastAttackedBy.damage = uncappedDamage;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t},\n\t\t\tonAccuracy(accuracy, target, source, move) {\n\t\t\t\tif (move.id === 'swift') {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn accuracy;\n\t\t\t},\n\t\t\tonEnd(target) {\n\t\t\t\tthis.add('-end', target, 'Substitute');\n\t\t\t},\n\t\t},\n\t},\n\tswift: {\n\t\tinherit: true,\n\t\taccuracy: 100,\n\t},\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAIO,MAAM,QAA8D;AAAA,EAC1E,UAAU;AAAA,IACT,SAAS;AAAA,IACT,WAAW;AAAA,MACV,QAAQ;AAAA,MACR,QAAQ;AAAA,IACT;AAAA,EACD;AAAA,EACA,YAAY;AAAA,IACX,SAAS;AAAA,IACT,WAAW;AAAA,MACV,QAAQ,QAAQ;AACf,aAAK,IAAI,UAAU,QAAQ,YAAY;AACvC,aAAK,YAAY,KAAK,KAAK,MAAM,OAAO,QAAQ,CAAC,IAAI;AACrD,eAAO,OAAO,UAAU,kBAAkB;AAAA,MAC3C;AAAA,MACA,kBAAkB;AAAA,MAClB,SAAS,QAAQ,QAAQ,MAAM;AAC9B,YAAI,KAAK,OAAO;AACf,eAAK,IAAI,SAAS,MAAM;AACxB,eAAK,KAAK,oFAAoF;AAC9F,iBAAO;AAAA,QACR;AACA,YAAI,KAAK,aAAa,UAAU;AAG/B,gBAAM,aAAa,CAAC,UAAU,YAAY,cAAc,WAAW;AACnE,cAAK,KAAK,UAAU,CAAC,OAAO,KAAK,EAAE,SAAS,KAAK,MAAM,KAAO,KAAK,UAAU,WAAW,UACvF,KAAK,mBAAmB,eAAe,WAAW,SAAS,KAAK,EAAE,GAAG;AACrE,mBAAO;AAAA,UACR;AACA;AAAA,QACD;AACA,YAAI,KAAK,kBAAkB,WAAW;AAAQ;AAI9C,YAAI,iBAAiB,KAAK,MAAM,IAAI,KAAK,aAAa,KAAK,QAAQ,UAAU,QAAQ,QAAQ,IAAI;AACjG,YAAI,CAAC,kBAAkB,mBAAmB;AAAG,iBAAO;AACpD,yBAAiB,KAAK,SAAS,aAAa,QAAQ,QAAQ,MAAM,cAAc;AAChF,YAAI,CAAC,kBAAkB,mBAAmB;AAAG,iBAAO;AACpD,aAAK,aAAa;AAClB,eAAO,UAAU,YAAY,EAAE,MAAM,iBAAiB,OAAO,UAAU,YAAY,EAAE,KACpF,OAAO,UAAU,YAAY,EAAE,KAAK;AACrC,YAAI,OAAO,UAAU,YAAY,EAAE,MAAM,GAAG;AAC3C,iBAAO,eAAe,YAAY;AAClC,iBAAO,aAAa;AAAA,QACrB,OAAO;AACN,eAAK,IAAI,aAAa,QAAQ,cAAc,UAAU;AAAA,QACvD;AAEA,YAAI,OAAO,UAAU,YAAY,GAAG;AACnC,cAAI,KAAK,QAAQ;AAChB,iBAAK,OAAO,KAAK,MAAM,iBAAiB,KAAK,OAAO,CAAC,IAAI,KAAK,OAAO,CAAC,CAAC,GAAG,QAAQ,QAAQ,QAAQ;AAAA,UACnG;AACA,cAAI,KAAK,OAAO;AACf,iBAAK,KAAK,KAAK,KAAK,iBAAiB,KAAK,MAAM,CAAC,IAAI,KAAK,MAAM,CAAC,CAAC,GAAG,QAAQ,QAAQ,OAAO;AAAA,UAC7F;AAAA,QACD;AACA,aAAK,SAAS,kBAAkB,QAAQ,QAAQ,MAAM,cAAc;AAEpE,cAAM,iBAAiB,OAAO,kBAAkB;AAChD,YAAI,CAAC,gBAAgB;AACpB,iBAAO,WAAW,KAAK,EAAC,QAAgB,MAAM,KAAK,IAAI,QAAQ,gBAAgB,UAAU,MAAM,MAAM,OAAO,QAAQ,EAAC,CAAC;AAAA,QACvH,OAAO;AACN,yBAAe,OAAO,KAAK;AAC3B,yBAAe,SAAS;AAAA,QACzB;AACA,eAAO;AAAA,MACR;AAAA,MACA,WAAW,UAAU,QAAQ,QAAQ,MAAM;AAC1C,YAAI,KAAK,OAAO,SAAS;AACxB,iBAAO;AAAA,QACR;AACA,eAAO;AAAA,MACR;AAAA,MACA,MAAM,QAAQ;AACb,aAAK,IAAI,QAAQ,QAAQ,YAAY;AAAA,MACtC;AAAA,IACD;AAAA,EACD;AAAA,EACA,OAAO;AAAA,IACN,SAAS;AAAA,IACT,UAAU;AAAA,EACX;AACD;",
  "names": []
}
