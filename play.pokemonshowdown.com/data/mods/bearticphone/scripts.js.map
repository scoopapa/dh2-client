{
  "version": 3,
  "sources": ["../../../../data/mods/bearticphone/scripts.ts"],
  "sourcesContent": ["export const Scripts: {[k: string]: ModdedBattleScriptsData} = {\n\tgen: 9,\n\tactions: {\n\t\tinherit: true,\n\t   runMove(\n\t\t   moveOrMoveName: Move | string, pokemon: Pokemon, targetLoc: number, sourceEffect?: Effect | null,\n\t   \tzMove?: string, externalMove?: boolean, maxMove?: string, originalTarget?: Pokemon\n   \t) {\n\t   \tpokemon.activeMoveActions++;\n\t   \tlet target = this.battle.getTarget(pokemon, maxMove || zMove || moveOrMoveName, targetLoc, originalTarget);\n\t   \tlet baseMove = this.dex.getActiveMove(moveOrMoveName);\n\t   \tconst pranksterBoosted = baseMove.pranksterBoosted;\n   \t\tif (baseMove.id !== 'struggle' && !zMove && !maxMove && !externalMove) {\n\t   \t\tconst changedMove = this.battle.runEvent('OverrideAction', pokemon, target, baseMove);\n\t   \t\tif (changedMove && changedMove !== true) {\n\t\t   \t\tbaseMove = this.dex.getActiveMove(changedMove);\n\t\t   \t\tif (pranksterBoosted) baseMove.pranksterBoosted = pranksterBoosted;\n\t\t   \t\ttarget = this.battle.getRandomTarget(pokemon, baseMove);\n\t\t   \t}\n\t   \t}\n   \t\tlet move = baseMove;\n\t   \tif (zMove) {\n\t   \t\tmove = this.getActiveZMove(baseMove, pokemon);\n\t   \t} else if (maxMove) {\n\t\t   \tmove = this.getActiveMaxMove(baseMove, pokemon);\n\t   \t}\n\n\t   \tmove.isExternal = externalMove;\n\n\t   \tthis.battle.setActiveMove(move, pokemon, target);\n\n\t   \tconst willTryMove = this.battle.runEvent('BeforeMove', pokemon, target, move);\n   \t\tif (!willTryMove) {\n\t\t   \tthis.battle.runEvent('MoveAborted', pokemon, target, move);\n\t\t   \tthis.battle.clearActiveMove(true);\n\t\t\t   pokemon.moveThisTurnResult = willTryMove;\n\t\t\t   return;\n\t\t   }\n\n\t\t   if (move.flags['cantusetwice'] && pokemon.lastMove?.id === move.id) {\n\t\t   \tpokemon.addVolatile(move.id);\n\t\t   }\n\n\t\t   if (move.beforeMoveCallback) {\n\t\t\t   if (move.beforeMoveCallback.call(this.battle, pokemon, target, move)) {\n\t\t\t\t   this.battle.clearActiveMove(true);\n\t\t\t\t   pokemon.moveThisTurnResult = false;\n\t\t\t\t   return;\n\t\t\t   }\n\t\t   }\n\t\t   pokemon.lastDamage = 0;\n\t\t   let lockedMove;\n\t\t   if (!externalMove) {\n\t\t   \tlockedMove = this.battle.runEvent('LockMove', pokemon);\n\t\t   \tif (lockedMove === true) lockedMove = false;\n\t\t   \tif (!lockedMove) {\n\t\t\t    \tif (!pokemon.deductPP(baseMove, null, target) && (move.id !== 'struggle')) {\n\t\t\t\t   \tthis.battle.add('cant', pokemon, 'nopp', move);\n\t\t\t\t   \tthis.battle.clearActiveMove(true);\n\t\t\t\t   \tpokemon.moveThisTurnResult = false;\n\t\t\t\t   \treturn;\n\t\t\t   \t}\n\t   \t\t} else {\n\t\t   \t\tsourceEffect = this.dex.conditions.get('lockedmove');\n\t\t    \t}\n\t\t\t   pokemon.moveUsed(move, targetLoc);\n\t   \t}\n\n\t\t   const noLock = externalMove && !pokemon.volatiles['lockedmove'];\n\n\t   \tif (zMove) {\n\t\t\t   if (pokemon.illusion) {\n\t\t\t   \tthis.battle.singleEvent('End', this.dex.abilities.get('Illusion'), pokemon.abilityState, pokemon);\n\t\t   \t}\n\t\t   \tthis.battle.add('-zpower', pokemon);\n\t\t   \tpokemon.side.zMoveUsed = true;\n\t   \t}\n\n\t   \tconst oldActiveMove = move;\n\n\t\t   const moveDidSomething = this.useMove(baseMove, pokemon, target, sourceEffect, zMove, maxMove);\n\t   \tthis.battle.lastSuccessfulMoveThisTurn = moveDidSomething ? this.battle.activeMove && this.battle.activeMove.id : null;\n\t   \tif (this.battle.activeMove) move = this.battle.activeMove;\n\t   \tthis.battle.singleEvent('AfterMove', move, null, pokemon, target, move);\n\t   \tthis.battle.runEvent('AfterMove', pokemon, target, move);\n\t   \tif (move.flags['cantusetwice'] && pokemon.removeVolatile(move.id)) {\n\t   \t\tthis.battle.add('-hint', `Some effects can force a Pokemon to use ${move.name} again in a row.`);\n\t   \t}\n\n\t\t\t/*\n\t\t\t// Dancer's activation order is completely different from any other event, so it's handled separately\n\t\t\tif (moveDidSomething && !move.isExternal) {\n\t\t\t\tconst dancers = [];\n\t\t\t\tconst confusemoves = ['axekick', 'chatter', 'confuseray', 'confusion', 'dizzypunch', 'dynamicpunch', 'flatter', 'hurricane', 'magicaltorque',\n\t\t\t\t\t\t\t\t\t\t\t 'psybeam', 'rockclimb', 'secretpower', 'shadowpanic', 'signalbeam', 'strangesteam', 'supersonic', 'swagger', 'sweetkiss', 'teeterdance', 'waterpulse'];\n\t\t\t\tfor (const currentPoke of this.battle.getAllActive()) {\n\t\t\t\t\tif (pokemon === currentPoke || currentPoke.isSemiInvulnerable()) continue;\n\t\t\t\t\tif (currentPoke.hasAbility('twoleftfeet')) {\n\t\t\t\t\t\tif (!confusemoves.includes(move.id) && !confusemoves.includes(move.name)) continue;\n\t\t\t\t\t\tdancers.push(currentPoke);\n\t\t\t\t\t} else if (currentPoke.hasAbility('beantheredonethat') && move.category === 'Status') {\n\t\t\t\t\t\tif (['rototiller','flowershield','magneticflux','gearup'].includes(move.id)) {\n\t\t\t\t\t\t\tdancers.push(currentPoke);\n\t\t\t\t\t\t} else if (move.boosts) {\n\t\t\t\t\t\t\tlet i: BoostID;\n\t\t\t\t\t\t\tfor (i in move.boosts) {\n\t\t\t\t\t\t\t\tif (boost[i]! > 0) {\n\t\t\t\t\t\t\t\t\tdancers.push(currentPoke);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Dancer activates in order of lowest speed stat to highest\n\t\t\t\t// Note that the speed stat used is after any volatile replacements like Speed Swap,\n\t\t\t\t// but before any multipliers like Agility or Choice Scarf\n\t\t\t\t// Ties go to whichever Pokemon has had the ability for the least amount of time\n\t\t\t\tdancers.sort(\n\t\t\t\t\t(a, b) => -(b.storedStats['spe'] - a.storedStats['spe']) || b.abilityOrder - a.abilityOrder\n\t\t\t\t);\n\t\t\t\tconst targetOf1stDance = this.battle.activeTarget!;\n\t\t\t\tfor (const dancer of dancers) {\n\t\t\t\t\tif (this.battle.faintMessages()) break;\n\t\t\t\t\tif (dancer.fainted) continue;\n\t\t\t\t\tthis.battle.add('-activate', dancer, 'ability: ' + dancer.getAbility().name);\n\t\t\t\t\tconst dancersTarget = !targetOf1stDance.isAlly(dancer) && pokemon.isAlly(dancer) ?\n\t\t\t\t\t\ttargetOf1stDance :\n\t\t\t\t\t\tpokemon;\n\t\t\t\t\tconst dancersTargetLoc = dancer.getLocOf(dancersTarget);\n\t\t\t\t\tthis.runMove(move.id, dancer, dancersTargetLoc, this.dex.abilities.get(dancer.ability), undefined, true);\n\t\t\t\t}\n\t\t\t}*/\n\n\t   \tif (noLock && pokemon.volatiles['lockedmove']) delete pokemon.volatiles['lockedmove'];\n\t   \tthis.battle.faintMessages();\n\t   \tthis.battle.checkWin();\n   \t}\n   },\n\tteambuilderConfig: {\n\t\texcludeStandardTiers: true,\n\t\tcustomTiers: ['bear'],\n   },\n};\n"],
  "mappings": "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",
  "names": []
}
